# https://spinsel.dev/assets/2020-06-17-ghidra-brainfuck-processor-1/ghidra_docs/language_spec/html/sleigh_definitions.html

define endian=big;

define alignment=2;

define space ram type=ram_space size=2 default;
define space register type=register_space size=2;


define space address type=ram_space size=3;

# Overlapping names for general registers
define register offset=0 size=4 [er0 er1 er2 er3 er4 er5 er6 sp];
define register offset=0 size=2 [e0 r0 e1 r1 e2 r2 e3 r3 e4 r4 e5 r5 e6 r6 e7 r7];
define register offset=0 size=1 [_ _ r0h r0l _ _ r1h r1l _ _ r2h r2l _ _ r3h r3l _ _ r4h r4l _ _ r5h r5l _ _ r6h r6l _ _ r7h r7l];

define register offset=0x100 size=3 [pc];
define register offset=0x200 size=1 [ccr];

#define bitrange I=ccr[7,1] # Interrupt mask
#				UI=ccr[6,1] # User bit or interrupt mask
#				H=ccr[5,1] # Half-carry
#				U=ccr[4,1] # User bit
#				N=ccr[3,1] # Negative
#				Z=ccr[2,1] # Zero
#				V=ccr[1,1] # Overflow
#				C=ccr[0,1]; # Carry

#define register offset=0x100 size=1 [cp dp ep tp br];



# CCR Flags
@define I_FLAG   "ccr[7,1]"
@define UI_FLAG  "ccr[6,1]"
@define H_FLAG  "ccr[5,1]"
@define U_FLAG  "ccr[4,1]"
@define N_FLAG   "ccr[3,1]"
@define Z_FLAG   "ccr[2,1]"
@define V_FLAG   "ccr[1,1]"
@define C_FLAG   "ccr[0,1]"

#define token instruction_1byte(8)
#	opcode_8=(0,7)
#;

#define token instruction_2byte(16)
#	opcode_16=(0,3)
#	operand_size_16=(4,4)
#	imm8_16=(8,15)	
#	address_mode_16=(0,3)
#	register_16=(5,7)
#	opcode_wholeword = (0,15)
#	opcode_firstbyte = (0,7)
#	immediate_value_byte = (8,15)
#	opcode_00_04 = (0,4)
#	register_05_07 = (5,7)
#	opcode_08_15 = (8,15)
#;

#define token instruction_3byte(24)
#	opcode_24=(0,3)
#	operand_size_24=(4,4)
#	register_24=(5,7)
#	imm16_24=(16,23)
#;

#define token instruction_4byte(32)
#	opcode1_32bit = (0,7)
#	address_24bit = (8,31)
#	address_16bit = (8,23)
#	opcode2_32bit = (24,31)
#;

define token ins1(8)
	op4=(4,7)
	op8=(0,7)
	sreg=(4,7)
	dreg=(0,3)
	imm8=(0,7)
;

define token ins2(16)
	imm16=(0,15)
;

define token ins3(24)
	op24=(0,23)
;

macro push2(val) {
	*[register]:2 sp = val;
	sp = sp-2;
}

macro pop2(val) {
	sp = sp+2;
	val = *[register]:2 sp;
}

macro branch() {
	*[register]:3 sp = pc;
	sp = sp-4;
}

macro branchret() {
	sp = sp+4;
	pc = *[register]:3 sp;
}

macro push4(val) {
	*[register]:4 sp = val;
	sp = sp-4;
}

macro pop4(val) {
	sp = sp+4;
	val = *[register]:4 sp;
}

macro setResultFlags(result) {
	Z_FLAG = (result == 0);
	N_FLAG = (result s< 0);
}

macro additionFlags(operand1, operand2) {
	local AFmask = -1 >> 4;
	H_FLAG = (((operand1 & AFmask) + (operand2 & AFmask)) & (AFmask + 1)) != 0;
	V_FLAG = scarry(operand1, operand2);
	C_FLAG = carry(operand1, operand2);
}

# maps register names to fields
# attach variables [  register_05_07 register_24 register_16 ] [ r0 r1 r2 r3 r4 r5 fp sp ];
attach variables [ sreg dreg ] [ r0l r1l r2l r3l r4l r5l r6l r7l r0h r1h r2h r3h r4h r5h r6h r7h ];

:add.b imm8_2_0,dreg is op4=0b1000 & dreg; imm8
{
	additionFlags(dreg, imm8);
	dreg = dreg + imm8;
	setResultFlags(dreg);
}
:add.b sreg,dreg is op8=0b00001000; sreg & dreg
{
	additionFlags(dreg, sreg);
	dreg = dreg + sreg;
	setResultFlags(dreg);
}


############### DATA #############
#:mov.i.w imm16_24,register_24             is opcode_24=0b0101 & operand_size_24=1 & register_24 & imm16_24
#{
#	register_24 = imm16_24;
#}

#:mov.e.b imm8_16,register_16             is opcode_16=0b0101 & operand_size_16=0 & register_16 & imm8_16
#{
#	register_16 = imm8_16;
#}



##################### BRANCH ####################
#:pjsr    @address_24bit  is opcode1_32bit=0x03 & address_24bit
#{
#
#	push(pc);
#	pc = &address_24bit;
#	call  [address_24bit:3];
#}


#:jsr    @address_24bit  is opcode1_32bit=0x01 & address_24bit
#{
#   	push(pc);
#	pc = &address_24bit;
#	call  [address_24bit:3];
#}


#:prts   is opcode_wholeword=0x1119
#{
#	pop(pc);
#	return [pc];
#}


##################### LOGICAL OPERATIONS ####################
#:and.w RdFull,RrFull               is  {
#	RdFull = RdFull & RrFull;
#	$(Vflag) = 0;
#	setResultFlags(RdFull);
#}


##################### SYSTEM CONTROL ####################
#define pcodeop nop;
#:nop is opcode_8=0x0 
#{
#	nop();
#}
#
#
#define pcodeop sleep;
#:sleep is opcode_8=0b0011010 {
#	sleep();
#}
#
#
#:link  is opcode_firstbyte=0x17 & immediate_value_byte
#{
#		r0 = r0;
#}
#
#
#:unlk is opcode_8=0x0f
#{
#	sp = fp;
#	pop(sp);
#}
#
#
###################### ARITHMETIC OPERATIONS ####################
#:extu.b is opcode_00_04=0b10100 & register_05_07 & opcode_08_15=0b00010010
#{
#		register_05_07 = register_05_07 ^ 0xFF ;
#}
#
#
#:cmp.i.w imm16_24,register_24             is opcode_24=0b0100 & operand_size_24=1 & register_24 & imm16_24
#{
#	#TODO
#	register_24 = imm16_24;
#}
#
#:cmp.e.b imm8_16,register_16             is opcode_16=0b0100 & operand_size_16=0 & register_16 & imm8_16
#{
#	#TODO
#	register_16 = imm8_16;
#}