# https://spinsel.dev/assets/2020-06-17-ghidra-brainfuck-processor-1/ghidra_docs/language_spec/html/sleigh_definitions.html

# H8/300 reference: https://www.classes.cs.uchicago.edu/archive/2006/winter/23000-1/docs/h8300.pdf
# H8/300H reference: http://www.bitsavers.org/components/hitachi/h8/H8_300H_Programming_Manual.pdf

define endian=big;

define alignment=2;

define space ram type=ram_space size=2 default;
define space register type=register_space size=2;


define space address type=ram_space size=2;

# Overlapping names for general registers
#define register offset=0 size=4 [er0 er1 er2 er3 er4 er5 er6 sp];
#define register offset=0 size=2 [e0 r0 e1 r1 e2 r2 e3 r3 e4 r4 e5 r5 e6 r6 e7 r7];
#define register offset=0 size=1 [_ _ r0h r0l _ _ r1h r1l _ _ r2h r2l _ _ r3h r3l _ _ r4h r4l _ _ r5h r5l _ _ r6h r6l _ _ r7h r7l];
define register offset=0 size=2 [r0 r1 r2 r3 r4 r5 r6 sp];
define register offset=0 size=1 [r0h r0l r1h r1l r2h r2l r3h r3l r4h r4l r5h r5l r6h r6l r7h r7l];

define register offset=0x100 size=2 [pc];
define register offset=0x200 size=1 [ccr];

# CCR Flags
@define I_FLAG   "ccr[7,1]"
@define UI_FLAG  "ccr[6,1]"
@define H_FLAG  "ccr[5,1]"
@define U_FLAG  "ccr[4,1]"
@define N_FLAG   "ccr[3,1]"
@define Z_FLAG   "ccr[2,1]"
@define V_FLAG   "ccr[1,1]"
@define C_FLAG   "ccr[0,1]"

define token ins1(8)
	op4=(4,7)
	op8=(0,7)
	sreg=(4,7)
	dreg=(0,3)
	imm8=(0,7)
	simm8=(0,7) signed
	rs3=(4,6)
	rd3=(0,2)
	imm4=(0,3)
	bit=(4,6)
	ccfld=(0,3)
	b3=(3,3)
	b7=(7,7)
	lnyb=(0,3)
	hnyb=(4,7)
;

define token ins2(16)
	imm16=(0,15)
;

define token ins3(24)
	op24=(0,23)
;

macro push2(val) {
	*[register]:2 sp = val;
	sp = sp-2;
}

macro pop2(val) {
	sp = sp+2;
	val = *[register]:2 sp;
}

macro branch() {
	sp = sp-4;
	*:4 sp = inst_next;
}

macro branchret() {
	sp = sp+4;
	pc = *[register]:3 sp;
}

macro push4(val) {
	*[register]:4 sp = val;
	sp = sp-4;
}

macro pop4(val) {
	sp = sp+4;
	val = *[register]:4 sp;
}

macro setResultFlags(result) {
	$(Z_FLAG) = (result == 0); # Z_FLAG
	ccr[3,1] = (result s< 0); # N_FLAG
}

macro additionFlags(operand1, operand2) {
	local AFmask = -1 >> 4;
	ccr[5,1] = (((operand1 & AFmask) + (operand2 & AFmask)) & (AFmask + 1)) != 0; # H_FLAG
	ccr[1,1] = scarry(operand1, operand2); # V_FLAG
	ccr[0,1] = carry(operand1, operand2); # C_FLAG
}

# maps register names to fields
attach variables [ sreg dreg ] [ r0l r1l r2l r3l r4l r5l r6l r7l r0h r1h r2h r3h r4h r5h r6h r7h ];
attach variables [ rs3 rd3 ] [ r0 r1 r2 r3 r4 r5 r6 sp ];

# H8/300 instructions

imm8mem.b: @imm8 is imm8 { export *:1 imm8; }
pcoff8: reloc is simm8 [ reloc=inst_next+simm8; ] { export *:3 reloc; }

cc: "ra" is ccfld=0 { export 1:1; }
cc: "rn" is ccfld=1 { export 0:1; }
cc: "hi" is ccfld=2 { tmp:1 = !($(C_FLAG) || $(Z_FLAG)); export tmp; }
cc: "ls" is ccfld=3 { tmp:1 = $(C_FLAG) || $(Z_FLAG); export tmp; }
cc: "cc" is ccfld=4 { tmp:1 = !$(C_FLAG); export tmp; }
cc: "cs" is ccfld=5 { tmp:1 = $(C_FLAG); export tmp; }
cc: "ne" is ccfld=6 { tmp:1 = !$(Z_FLAG); export tmp; }
cc: "eq" is ccfld=7 { tmp:1 = $(Z_FLAG); export tmp; }
cc: "vc" is ccfld=8 { tmp:1 = !$(V_FLAG); export tmp; }
cc: "vs" is ccfld=9 { tmp:1 = $(V_FLAG); export tmp; }
cc: "pl" is ccfld=10 { tmp:1 = !$(N_FLAG); export tmp; }
cc: "mi" is ccfld=11 { tmp:1 = $(N_FLAG); export tmp; }
cc: "ge" is ccfld=12 { tmp:1 = ($(V_FLAG)==$(N_FLAG)); export tmp; }
cc: "lt" is ccfld=13 { tmp:1 = ($(V_FLAG)!=$(N_FLAG)); export tmp; }
cc: "gt" is ccfld=14 { tmp:1 = !$(Z_FLAG) && ($(V_FLAG)==$(N_FLAG)); export tmp; }
cc: "le" is ccfld=15 { tmp:1 = $(Z_FLAG) || ($(V_FLAG)!=$(N_FLAG)); export tmp; }


:add.b #imm8,dreg is op4=0x8 & dreg; imm8 {
	additionFlags(dreg, imm8);
	dreg = dreg + imm8;
	setResultFlags(dreg);
}
:add.b sreg,dreg is op8=0x08; sreg & dreg {
	additionFlags(dreg, sreg);
	dreg = dreg + sreg;
	setResultFlags(dreg);
}
:add.w rs3,rd3 is op8=0x09; b7=0 & rs3 & b3=0 & rd3 {
	additionFlags(rd3, rs3);
	rd3 = rd3 + rs3;
	setResultFlags(rd3);
}
:adds #1,rd3 is op8=0x0B; op4=0 & b3=0 & rd3 { rd3 = rd3 + 1; }
:adds #2,rd3 is op8=0x0B; op4=8 & b3=0 & rd3 { rd3 = rd3 + 2; }
:addx #imm8,dreg is op4=0x9 & dreg; imm8 {
	local srcop = imm8 + $(C_FLAG);
	additionFlags(dreg, srcop);
	dreg = dreg + srcop;
	setResultFlags(dreg);
}
:addx sreg,dreg is op8=0x0E; sreg & dreg {
	local srcop = sreg + $(C_FLAG);
	additionFlags(dreg, srcop);
	dreg = dreg + srcop;
	setResultFlags(dreg);
}
:and #imm8,dreg is op4=0xE & dreg; imm8 {
	dreg = dreg & imm8;
	setResultFlags(dreg);
	$(V_FLAG) = 0;
}
:and sreg,dreg is op8=0x16; sreg & dreg {
	dreg = dreg & sreg;
	setResultFlags(dreg);
	$(V_FLAG) = 0;
}
:andc #imm8,"ccr" is op8=0x06; imm8 { ccr = ccr & imm8; }

:b^cc pcoff8 is op4=4 & cc; pcoff8 {
	if (cc) goto pcoff8;
}

:band #bit,dreg is op8=0x76; b7=0 & bit & dreg {
	local rbit = (dreg >> bit) & 1;
	$(C_FLAG) = $(C_FLAG) & rbit;
}
:band #bit,@rs3 is op8=0x7C; b7=0 & rs3 & lnyb=0; op8=0x76; b7=0 & bit & lnyb=0 { 
	$(C_FLAG) = $(C_FLAG) & ((* rs3) >> bit);
}
:band #bit,imm8mem.b is op8=0x7E; imm8mem.b; op8=0x76; b7=0 & bit & lnyb=0 {
	$(C_FLAG) = $(C_FLAG) & (imm8mem.b >> bit);
}
:bclr #bit,dreg is op8=0x72; b7=0 & bit & dreg {
	dreg = dreg & ~(1 << bit);
}
:bclr #bit,@rs3 is op8=0x7D; b7=0 & rs3 & lnyb=0; op8=0x72; b7=0 & bit & lnyb=0 {
	* rs3 = (*:1 rs3) & ~(1 << bit);
}
:bclr #bit,imm8mem.b is op8=0x7F; imm8mem.b; op8=0x72; b7=0 & bit & lnyb=0 {
	imm8mem.b = imm8mem.b &  ~(1 << bit);
}
:bclr sreg,dreg is op8=0x62; sreg & dreg {
	dreg = dreg & ~(1 << (sreg & 7));
}
:bclr sreg,@rs3 is op8=0x7D; b7=0 & rs3 & lnyb=0; op8=0x62; sreg & lnyb=0 {
	* rs3 = (*:1 rs3) & ~(1 << (sreg & 7));
}
:bclr sreg,imm8mem.b is op8=0x7F; imm8mem.b; op8=0x62; sreg & lnyb=0 {
	imm8mem.b = imm8mem.b &  ~(1 << (sreg & 7));
}
:biand #bit,dreg is op8=0x76; b7=1 & bit & dreg {
	local rbit = ~((dreg >> bit) & 1);
	$(C_FLAG) = $(C_FLAG) & rbit;
}
:biand #bit,@rs3 is op8=0x7C; b7=0 & rs3 & lnyb=0; op8=0x76; b7=1 & bit & lnyb=0 { 
	$(C_FLAG) = $(C_FLAG) & ~((* rs3) >> bit);
}
:biand #bit,imm8mem.b is op8=0x7E; imm8mem.b; op8=0x76; b7=1 & bit & lnyb=0 {
	$(C_FLAG) = $(C_FLAG) & ~(imm8mem.b >> bit);
}
:bild #bit,dreg is op8=0x77; b7=1 & bit & dreg {
	$(C_FLAG) = ~((dreg >> bit) & 1);
}
:bild #bit,@rs3 is op8=0x7C; b7=0 & rs3 & lnyb=0; op8=0x77; b7=1 & bit & lnyb=0 { 
	$(C_FLAG) = ~((* rs3) >> bit);
}
:bild #bit,imm8mem.b is op8=0x7E; imm8mem.b; op8=0x77; b7=1 & bit & lnyb=0 {
	$(C_FLAG) = ~(imm8mem.b >> bit);
}
:bior #bit,dreg is op8=0x74; b7=1 & bit & dreg {
	local rbit = ~((dreg >> bit) & 1);
	$(C_FLAG) = $(C_FLAG) | rbit;
}
:bior #bit,@rs3 is op8=0x7C; b7=0 & rs3 & lnyb=0; op8=0x74; b7=1 & bit & lnyb=0 { 
	$(C_FLAG) = $(C_FLAG) | ~((* rs3) >> bit);
}
:bior #bit,imm8mem.b is op8=0x7E; imm8mem.b; op8=0x74; b7=1 & bit & lnyb=0 {
	$(C_FLAG) = $(C_FLAG) | ~(imm8mem.b >> bit);
}
:bist #bit,dreg is op8=0x67; b7=1 & bit & dreg {
	local masked = dreg & ~(1 << bit);
	dreg = masked | (~$(C_FLAG) << bit);
}
:bist #bit,@rs3 is op8=0x7D; b7=0 & rs3 & lnyb=0; op8=0x67; b7=1 & bit & lnyb=0 {
	local masked = (*:1 rs3) & ~(1 << bit);
	* rs3 = masked | (~$(C_FLAG) << bit);
}
:bist #bit,imm8mem.b is op8=0x7F; imm8mem.b; op8=0x67; b7=1 & bit & lnyb=0 {
	local masked = imm8mem.b &  ~(1 << bit);
	imm8mem.b = masked | (~$(C_FLAG) << bit);
}
:bixor #bit,dreg is op8=0x75; b7=1 & bit & dreg {
	local rbit = ~((dreg >> bit) & 1);
	$(C_FLAG) = $(C_FLAG) ^ rbit;
}
:bixor #bit,@rs3 is op8=0x7C; b7=0 & rs3 & lnyb=0; op8=0x75; b7=1 & bit & lnyb=0 { 
	$(C_FLAG) = $(C_FLAG) ^ ~((* rs3) >> bit);
}
:bixor #bit,imm8mem.b is op8=0x7E; imm8mem.b; op8=0x75; b7=1 & bit & lnyb=0 {
	$(C_FLAG) = $(C_FLAG) ^ ~(imm8mem.b >> bit);
}
:bld #bit,dreg is op8=0x77; b7=0 & bit & dreg {
	$(C_FLAG) = ((dreg >> bit) & 1);
}
:bld #bit,@rs3 is op8=0x7C; b7=0 & rs3 & lnyb=0; op8=0x77; b7=0 & bit & lnyb=0 { 
	$(C_FLAG) = ((* rs3) >> bit);
}
:bld #bit,imm8mem.b is op8=0x7E; imm8mem.b; op8=0x77; b7=0 & bit & lnyb=0 {
	$(C_FLAG) = (imm8mem.b >> bit);
}
:bnot #bit,dreg is op8=0x71; b7=0 & bit & dreg {
	dreg = dreg ^ (1<<bit);
}
:bnot #bit,@rs3 is op8=0x7D; b7=0 & rs3 & lnyb=0; op8=0x71; b7=0 & bit & lnyb=0 {
	* rs3 = (*:1 rs3) ^ (1 << bit);
}
:bnot #bit,imm8mem.b is op8=0x7F; imm8mem.b; op8=0x71; b7=0 & bit & lnyb=0 {
	imm8mem.b = imm8mem.b ^ (1<<bit);
}
:bnot sreg,dreg is op8=0x61; sreg & dreg {
	dreg = dreg ^ (1<<(sreg&7));
}
:bnot sreg,@rs3 is op8=0x7D; b7=0 & rs3 & lnyb=0; op8=0x61; sreg & lnyb=0 {
	* rs3 = (*:1 rs3) ^ (1<<(sreg&7));
}
:bnot sreg,imm8mem.b is op8=0x7F; imm8mem.b; op8=0x61; sreg & lnyb=0 {
	imm8mem.b = imm8mem.b ^ (1<<(sreg&7));
}
:bor #bit,dreg is op8=0x74; b7=0 & bit & dreg {
	local rbit = ((dreg >> bit) & 1);
	$(C_FLAG) = $(C_FLAG) | rbit;
}
:bor #bit,@rs3 is op8=0x7C; b7=0 & rs3 & lnyb=0; op8=0x74; b7=0 & bit & lnyb=0 { 
	$(C_FLAG) = $(C_FLAG) | ((* rs3) >> bit);
}
:bor #bit,imm8mem.b is op8=0x7E; imm8mem.b; op8=0x74; b7=0 & bit & lnyb=0 {
	$(C_FLAG) = $(C_FLAG) | (imm8mem.b >> bit);
}
:bset #bit,dreg is op8=0x70; b7=0 & bit & dreg {
	dreg = dreg | (1 << bit);
}
:bset #bit,@rs3 is op8=0x7D; b7=0 & rs3 & lnyb=0; op8=0x70; b7=0 & bit & lnyb=0 {
	* rs3 = (*:1 rs3) | (1 << bit);
}
:bset #bit,imm8mem.b is op8=0x7F; imm8mem.b; op8=0x70; b7=0 & bit & lnyb=0 {
	imm8mem.b = imm8mem.b | (1 << bit);
}
:bset sreg,dreg is op8=0x60; sreg & dreg {
	dreg = dreg | (1 << (sreg & 7));
}
:bset sreg,@rs3 is op8=0x7D; b7=0 & rs3 & lnyb=0; op8=0x60; sreg & lnyb=0 {
	* rs3 = (*:1 rs3) | (1 << (sreg & 7));
}
:bset sreg,imm8mem.b is op8=0x7F; imm8mem.b; op8=0x60; sreg & lnyb=0 {
	imm8mem.b = imm8mem.b | (1 << (sreg & 7));
}
:bst #bit,dreg is op8=0x67; b7=0 & bit & dreg {
	local masked = dreg & ~(1 << bit);
	dreg = masked | ($(C_FLAG) << bit);
}
:bst #bit,@rs3 is op8=0x7D; b7=0 & rs3 & lnyb=0; op8=0x67; b7=0 & bit & lnyb=0 {
	local masked = (*:1 rs3) & ~(1 << bit);
	* rs3 = masked | ($(C_FLAG) << bit);
}
:bst #bit,imm8mem.b is op8=0x7F; imm8mem.b; op8=0x67; b7=0 & bit & lnyb=0 {
	local masked = imm8mem.b &  ~(1 << bit);
	imm8mem.b = masked | ($(C_FLAG) << bit);
}
:btst #bit,dreg is op8=0x73; b7=0 & bit & dreg {
	$(Z_FLAG) = ~(dreg >> bit) & 1;
}
:btst #bit,@rs3 is op8=0x7C; b7=0 & rs3 & lnyb=0; op8=0x73; b7=0 & bit & lnyb=0 {
	$(Z_FLAG) = ~((*:1 rs3) >> bit) & 1;
}
:btst #bit,imm8mem.b is op8=0x7E; imm8mem.b; op8=0x73 & b7=0 & bit & lnyb=0 {
	$(Z_FLAG) = ~(imm8mem.b >> bit) & 1;
}
:btst sreg,dreg is op8=0x63; sreg & dreg {
	$(Z_FLAG) = ~(dreg >> (sreg & 7)) & 1;
}
:btst sreg,@rs3 is op8=0x7C; b7=0 & rs3 & lnyb=0; op8=0x63; sreg & lnyb=0 {
	$(Z_FLAG) = ~((*:1 rs3) >> (sreg & 7)) & 1;
}
:btst sreg,imm8mem.b is op8=0x7E; imm8mem.b; op8=0x63; sreg & lnyb=0 {
	$(Z_FLAG) = ~(imm8mem.b >> (sreg & 7)) & 1;
}
:bxor #bit,dreg is op8=0x75; b7=0 & bit & dreg {
	local rbit = ((dreg >> bit) & 1);
	$(C_FLAG) = $(C_FLAG) ^ rbit;
}
:bxor #bit,@rs3 is op8=0x7C; b7=0 & rs3 & lnyb=0; op8=0x75; b7=0 & bit & lnyb=0 { 
	$(C_FLAG) = $(C_FLAG) ^ ((* rs3) >> bit) & 1;
}
:bxor #bit,imm8mem.b is op8=0x7E; imm8mem.b; op8=0x75; b7=0 & bit & lnyb=0 {
	$(C_FLAG) = $(C_FLAG) ^ (imm8mem.b >> bit) & 1;
}


:bsr pcoff8 is op8=0x55; pcoff8 {
	sp = sp-2;
	* sp = (&:2 inst_next);
	call pcoff8;
}


############### DATA #############
#:mov.i.w imm16_24,register_24             is opcode_24=0b0101 & operand_size_24=1 & register_24 & imm16_24
#{
#	register_24 = imm16_24;
#}

#:mov.e.b imm8_16,register_16             is opcode_16=0b0101 & operand_size_16=0 & register_16 & imm8_16
#{
#	register_16 = imm8_16;
#}



##################### BRANCH ####################
#:pjsr    @address_24bit  is opcode1_32bit=0x03 & address_24bit
#{
#
#	push(pc);
#	pc = &address_24bit;
#	call  [address_24bit:3];
#}


#:jsr    @address_24bit  is opcode1_32bit=0x01 & address_24bit
#{
#   	push(pc);
#	pc = &address_24bit;
#	call  [address_24bit:3];
#}


#:prts   is opcode_wholeword=0x1119
#{
#	pop(pc);
#	return [pc];
#}


##################### LOGICAL OPERATIONS ####################
#:and.w RdFull,RrFull               is  {
#	RdFull = RdFull & RrFull;
#	$(Vflag) = 0;
#	setResultFlags(RdFull);
#}


##################### SYSTEM CONTROL ####################
#define pcodeop nop;
#:nop is opcode_8=0x0 
#{
#	nop();
#}
#
#
#define pcodeop sleep;
#:sleep is opcode_8=0b0011010 {
#	sleep();
#}
#
#
#:link  is opcode_firstbyte=0x17 & immediate_value_byte
#{
#		r0 = r0;
#}
#
#
#:unlk is opcode_8=0x0f
#{
#	sp = fp;
#	pop(sp);
#}
#
#
###################### ARITHMETIC OPERATIONS ####################
#:extu.b is opcode_00_04=0b10100 & register_05_07 & opcode_08_15=0b00010010
#{
#		register_05_07 = register_05_07 ^ 0xFF ;
#}
#
#
#:cmp.i.w imm16_24,register_24             is opcode_24=0b0100 & operand_size_24=1 & register_24 & imm16_24
#{
#	#TODO
#	register_24 = imm16_24;
#}
#
#:cmp.e.b imm8_16,register_16             is opcode_16=0b0100 & operand_size_16=0 & register_16 & imm8_16
#{
#	#TODO
#	register_16 = imm8_16;
#}