# https://spinsel.dev/assets/2020-06-17-ghidra-brainfuck-processor-1/ghidra_docs/language_spec/html/sleigh_definitions.html

# H8/300 reference: https://www.classes.cs.uchicago.edu/archive/2006/winter/23000-1/docs/h8300.pdf
# H8/300H reference: http://www.bitsavers.org/components/hitachi/h8/H8_300H_Programming_Manual.pdf

define endian=big;

define alignment=2;

define space ram type=ram_space size=2 default;
define space register type=register_space size=2;


define space address type=ram_space size=3;

# Overlapping names for general registers
define register offset=0 size=4 [er0 er1 er2 er3 er4 er5 er6 sp];
define register offset=0 size=2 [e0 r0 e1 r1 e2 r2 e3 r3 e4 r4 e5 r5 e6 r6 e7 r7];
define register offset=0 size=1 [_ _ r0h r0l _ _ r1h r1l _ _ r2h r2l _ _ r3h r3l _ _ r4h r4l _ _ r5h r5l _ _ r6h r6l _ _ r7h r7l];

define register offset=0x100 size=3 [pc];
define register offset=0x200 size=1 [ccr];

# CCR Flags
@define I_FLAG   "ccr[7,1]"
@define UI_FLAG  "ccr[6,1]"
@define H_FLAG  "ccr[5,1]"
@define U_FLAG  "ccr[4,1]"
@define N_FLAG   "ccr[3,1]"
@define Z_FLAG   "ccr[2,1]"
@define V_FLAG   "ccr[1,1]"
@define C_FLAG   "ccr[0,1]"

define token ins1(8)
	op4=(4,7)
	op8=(0,7)
	sreg=(4,7)
	dreg=(0,3)
	imm8=(0,7)
	rs3=(4,6)
	rd3=(0,2)
	imm4=(0,3)
;

define token ins2(16)
	imm16=(0,15)
;

define token ins3(24)
	op24=(0,23)
;

macro push2(val) {
	*[register]:2 sp = val;
	sp = sp-2;
}

macro pop2(val) {
	sp = sp+2;
	val = *[register]:2 sp;
}

macro branch() {
	*[register]:3 sp = pc;
	sp = sp-4;
}

macro branchret() {
	sp = sp+4;
	pc = *[register]:3 sp;
}

macro push4(val) {
	*[register]:4 sp = val;
	sp = sp-4;
}

macro pop4(val) {
	sp = sp+4;
	val = *[register]:4 sp;
}

macro setResultFlags(result) {
	ccr[2,1] = (result == 0); # Z_FLAG
	ccr[3,1] = (result s< 0); # N_FLAG
}

macro additionFlags(operand1, operand2) {
	local AFmask = -1 >> 4;
	ccr[5,1] = (((operand1 & AFmask) + (operand2 & AFmask)) & (AFmask + 1)) != 0; # H_FLAG
	ccr[1,1] = scarry(operand1, operand2); # V_FLAG
	ccr[0,1] = carry(operand1, operand2); # C_FLAG
}

# maps register names to fields
attach variables [ sreg dreg ] [ r0l r1l r2l r3l r4l r5l r6l r7l r0h r1h r2h r3h r4h r5h r6h r7h ];
attach variables [ rs3 rd3 ] [ r0 r1 r2 r3 r4 r5 r6 r7 ];

# H8/300 instructions

:add.b #imm8,dreg is op4=0x8 & dreg; imm8 {
	additionFlags(dreg, imm8);
	dreg = dreg + imm8;
	setResultFlags(dreg);
}
:add.b sreg,dreg is op8=0x08; sreg & dreg {
	additionFlags(dreg, sreg);
	dreg = dreg + sreg;
	setResultFlags(dreg);
}
:add.w rs3,rd3 is op8=0x09; rs3 & rd3 {
	additionFlags(rd3, rs3);
	rd3 = rd3 + rs3;
	setResultFlags(rd3);
}
:adds #1,rd3 is op8=0x0B; op4=0 & rd3 { rd3 = rd3 + 1; }
:adds #2,rd3 is op8=0x0B; op4=8 & rd3 { rd3 = rd3 + 2; }
:addx #imm8,dreg is op4=0x9 & dreg; imm8 {
	local srcop = imm8 + $(C_FLAG);
	additionFlags(dreg, srcop);
	dreg = dreg + srcop;
	setResultFlags(dreg);
}
:addx sreg,dreg is op8=0x0E; sreg & dreg {
	local srcop = sreg + $(C_FLAG);
	additionFlags(dreg, srcop);
	dreg = dreg + srcop;
	setResultFlags(dreg);
}
:and #imm8,dreg is op4=0xE & dreg; imm8 {
	dreg = dreg & imm8;
	setResultFlags(dreg);
	$(V_FLAG) = 0;
}
:and sreg,dreg is op8=0x16; sreg & dreg {
	dreg = dreg & sreg;
	setResultFlags(dreg);
	$(V_FLAG) = 0;
}
:andc #imm8,"ccr" is op8=0x06; imm8 { ccr = ccr & imm8; }


############### DATA #############
#:mov.i.w imm16_24,register_24             is opcode_24=0b0101 & operand_size_24=1 & register_24 & imm16_24
#{
#	register_24 = imm16_24;
#}

#:mov.e.b imm8_16,register_16             is opcode_16=0b0101 & operand_size_16=0 & register_16 & imm8_16
#{
#	register_16 = imm8_16;
#}



##################### BRANCH ####################
#:pjsr    @address_24bit  is opcode1_32bit=0x03 & address_24bit
#{
#
#	push(pc);
#	pc = &address_24bit;
#	call  [address_24bit:3];
#}


#:jsr    @address_24bit  is opcode1_32bit=0x01 & address_24bit
#{
#   	push(pc);
#	pc = &address_24bit;
#	call  [address_24bit:3];
#}


#:prts   is opcode_wholeword=0x1119
#{
#	pop(pc);
#	return [pc];
#}


##################### LOGICAL OPERATIONS ####################
#:and.w RdFull,RrFull               is  {
#	RdFull = RdFull & RrFull;
#	$(Vflag) = 0;
#	setResultFlags(RdFull);
#}


##################### SYSTEM CONTROL ####################
#define pcodeop nop;
#:nop is opcode_8=0x0 
#{
#	nop();
#}
#
#
#define pcodeop sleep;
#:sleep is opcode_8=0b0011010 {
#	sleep();
#}
#
#
#:link  is opcode_firstbyte=0x17 & immediate_value_byte
#{
#		r0 = r0;
#}
#
#
#:unlk is opcode_8=0x0f
#{
#	sp = fp;
#	pop(sp);
#}
#
#
###################### ARITHMETIC OPERATIONS ####################
#:extu.b is opcode_00_04=0b10100 & register_05_07 & opcode_08_15=0b00010010
#{
#		register_05_07 = register_05_07 ^ 0xFF ;
#}
#
#
#:cmp.i.w imm16_24,register_24             is opcode_24=0b0100 & operand_size_24=1 & register_24 & imm16_24
#{
#	#TODO
#	register_24 = imm16_24;
#}
#
#:cmp.e.b imm8_16,register_16             is opcode_16=0b0100 & operand_size_16=0 & register_16 & imm8_16
#{
#	#TODO
#	register_16 = imm8_16;
#}