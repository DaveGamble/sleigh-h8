# https://spinsel.dev/assets/2020-06-17-ghidra-brainfuck-processor-1/ghidra_docs/language_spec/html/sleigh_definitions.html

define endian=big;

define alignment=2;

define space ram type=ram_space size=2 default;
define space register type=register_space size=2;


define space address type=ram_space size=3;

# Overlapping names for general registers
define register offset=0 size=4 [er0 er1 er2 er3 er4 er5 er6 sp];
define register offset=0 size=2 [e0 r0 e1 r1 e2 r2 e3 r3 e4 r4 e5 r5 e6 r6 e7 r7];
define register offset=0 size=1 [_ _ r0h r0l _ _ r1h r1l _ _ r2h r2l _ _ r3h r3l _ _ r4h r4l _ _ r5h r5l _ _ r6h r6l _ _ r7h r7l];

define register offset=0x100 size=3 [pc];
define register offset=0x200 size=1 [ccr];

define bitrange I=statusreg[7,1] # Interrupt mask
				UI=statusreg[6,1] # User bit or interrupt mask
				H=statusreg[5,1] # Half-carry
				U=statusreg[4,1] # User bit
				N=statusreg[3,1] # Negative
				Z=statusreg[2,1] # Zero
				V=statusreg[1,1] # Overflow
				C=statusreg[0,1]; # Carry

#define register offset=0x100 size=1 [cp dp ep tp br];



# SR Flags
#@define T_FLAG   "sr[15,1]"
#@define I0_FLAG  "sr[8,1]"
#@define I1_FLAG  "sr[9,1]"
#@define I2_FLAG  "sr[10,1]"
#@define N_FLAG   "sr[3,1]"
#@define Z_FLAG   "sr[2,1]"
#@define V_FLAG   "sr[1,1]"
#@define C_FLAG   "sr[0,1]"

#define token instruction_1byte(8)
#	opcode_8=(0,7)
#;

#define token instruction_2byte(16)
#	opcode_16=(0,3)
#	operand_size_16=(4,4)
#	imm8_16=(8,15)	
#	address_mode_16=(0,3)
#	register_16=(5,7)
#	opcode_wholeword = (0,15)
#	opcode_firstbyte = (0,7)
#	immediate_value_byte = (8,15)
#	opcode_00_04 = (0,4)
#	register_05_07 = (5,7)
#	opcode_08_15 = (8,15)
#;

#define token instruction_3byte(24)
#	opcode_24=(0,3)
#	operand_size_24=(4,4)
#	register_24=(5,7)
#	imm16_24=(16,23)
#;

#define token instruction_4byte(32)
#	opcode1_32bit = (0,7)
#	address_24bit = (8,31)
#	address_16bit = (8,23)
#	opcode2_32bit = (24,31)
#;

define token ins1(1)
	op4(4,7)
	op8(0,7)
	reg_u(4,7)
	reg_l(0,3)
	imm8(0,7)
;

define token ins2(2)
	imm16(0,15)
;

macro push2(val) {
	*[register]:2 sp = val;
	sp = sp-2;
}

macro pop2(val) {
	sp = sp+2;
	val = *[register]:2 sp;
}

macro branch() {
	*[register]:3 sp = pc;
	sp = sp-4;
}

macro branchret() {
	sp = sp+4;
	pc = *[register]:3 sp;
}

macro push4(val) {
	*[register]:4 sp = val;
	sp = sp-4;
}

macro pop4(val) {
	sp = sp+4;
	val = *[register]:4 sp;
}

macro setResultFlags(result) {
	Z = (result == 0);
	N = (result s< 0);
}

macro additionFlags(operand1, operand2) {
	local AFmask = -1 >> 4;
	H = (((operand1 & AFmask) + (operand2 & AFmask)) & (AFmask + 1)) != 0;
	V = scarry(operand1, operand2);
	C = carry(operand1, operand2);
}

# maps register names to fields
# attach variables [  register_05_07 register_24 register_16 ] [ r0 r1 r2 r3 r4 r5 fp sp ];
attach variables [ rd2_8 rs2_4 rd2_0 ] [ r0l r1l r2l r3l r4l r5l r6l r7l r0h r1h r2h r3h r4h r5h r6h r7h ];

:add.b imm8_2_0,rd2_8 is op4=0b1000 & regl & imm8_2_0
{
	additionFlags(rd2_8, imm8_2_0);
	rd2_8 = rd2_8 + imm8_2_0;
	setResultFlags(rd2_8);
}
:add.b rs2_4,rd2_0 is opcode_8=0b00001000 & rs2_4 & rd2_0
{
	additionFlags(rd2_0, rs2_4);
	rd2_0 = rd2_0 + rs2_4;
	setResultFlags(rd2_0);
}


############### DATA #############
:mov.i.w imm16_24,register_24             is opcode_24=0b0101 & operand_size_24=1 & register_24 & imm16_24
{
	register_24 = imm16_24;
}

:mov.e.b imm8_16,register_16             is opcode_16=0b0101 & operand_size_16=0 & register_16 & imm8_16
{
	register_16 = imm8_16;
}



##################### BRANCH ####################
:pjsr    @address_24bit  is opcode1_32bit=0x03 & address_24bit
{

	push(pc);
	pc = &address_24bit;
	call  [address_24bit:3];
}


:jsr    @address_24bit  is opcode1_32bit=0x01 & address_24bit
{
   	push(pc);
	pc = &address_24bit;
	call  [address_24bit:3];
}


:prts   is opcode_wholeword=0x1119
{
	pop(pc);
	return [pc];
}


##################### LOGICAL OPERATIONS ####################
:and.w RdFull,RrFull               is  {
	RdFull = RdFull & RrFull;
	$(Vflag) = 0;
	setResultFlags(RdFull);
}


##################### SYSTEM CONTROL ####################
define pcodeop nop;
:nop is opcode_8=0x0 
{
	nop();
}


define pcodeop sleep;
:sleep is opcode_8=0b0011010 {
	sleep();
}


:link  is opcode_firstbyte=0x17 & immediate_value_byte
{
		r0 = r0;
}


:unlk is opcode_8=0x0f
{
	sp = fp;
	pop(sp);
}


##################### ARITHMETIC OPERATIONS ####################
:extu.b is opcode_00_04=0b10100 & register_05_07 & opcode_08_15=0b00010010
{
		register_05_07 = register_05_07 ^ 0xFF ;
}


:cmp.i.w imm16_24,register_24             is opcode_24=0b0100 & operand_size_24=1 & register_24 & imm16_24
{
	#TODO
	register_24 = imm16_24;
}

:cmp.e.b imm8_16,register_16             is opcode_16=0b0100 & operand_size_16=0 & register_16 & imm8_16
{
	#TODO
	register_16 = imm8_16;
}
